"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var fs = require("fs");

var path = require("path");

var gitDiff = require("git-diff");

var _require = require("../lib.js"),
    getFiles = _require.getFiles,
    getCleanTokens = _require.getCleanTokens,
    preloadTerms = _require.preloadTerms,
    getHeaders = _require.getHeaders,
    getRelativePath = _require.getRelativePath,
    addJSImportStatement = _require.addJSImportStatement;

function parser(_x) {
  return _parser.apply(this, arguments);
}

function _parser() {
  _parser = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(options) {
    var termsFiles, termsData, allFiles, nmbMatches, regex, _iterator, _step, filepath, content, oldContent, headers, regex_matches, _iterator2, _step2, _loop, diff, result;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options.dryRun && console.log("\n* Dry run enabled *\n"); // Load the term files

            termsFiles = [];
            _context.prev = 2;
            _context.next = 5;
            return getFiles(options.termsDir, options.noParseFiles);

          case 5:
            termsFiles = _context.sent;
            _context.next = 13;
            break;

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](2);
            console.log("\u26A0  Not able to get files from folder: ".concat(options.termsDir));
            console.log("Check the path in option \"termsDir\"\n\n ".concat(_context.t0, " \nExiting..."));
            process.exit(1);

          case 13:
            if (termsFiles.length == 0) {
              console.log("\u26A0 No term files found");
              console.log("Might be wrong path \"".concat(options.termsDir, "\" in option ") + "\"termsDir\" or empty folder \nExiting...");
              process.exit(1);
            }

            _context.next = 16;
            return preloadTerms(termsFiles);

          case 16:
            termsData = _context.sent;
            console.log("Iterate through the .md(x) files, looking for term patterns");
            allFiles = [];
            _context.prev = 19;
            _context.next = 22;
            return getFiles(options.docsDir, options.noParseFiles);

          case 22:
            allFiles = _context.sent;
            _context.next = 30;
            break;

          case 25:
            _context.prev = 25;
            _context.t1 = _context["catch"](19);
            console.log("\u26A0  Not able to get files from folder: ".concat(options.docsDir));
            console.log("Check the path in option \"docsDir\"\n\n".concat(_context.t1, " \nExiting..."));
            process.exit(1);

          case 30:
            if (fs.lstatSync(options.docsDir).isFile() && path.extname(options.docsDir).includes(".md")) {
              console.log("! A single file to be parsed is given in option \"docsDir\":" + " \"".concat(options.docsDir, "\""));
              allFiles = [options.docsDir];
            }

            if (!allFiles.length) {
              console.log("\u26A0 No files found. Might be wrong path" + " \"".concat(options.docsDir, "\" in option \"docsDir\" or empty folder")); // process.exit(1);
            } // start counting number of term replacements


            nmbMatches = 0;
            regex = new RegExp("\\%%.*?\\" + options.patternSeparator + ".*?\\%%", "g");
            _iterator = _createForOfIteratorHelper(allFiles);
            _context.prev = 35;

            _iterator.s();

          case 37:
            if ((_step = _iterator.n()).done) {
              _context.next = 81;
              break;
            }

            filepath = _step.value;
            content = "";
            _context.prev = 40;
            _context.next = 43;
            return fs.promises.readFile(filepath, "utf8");

          case 43:
            content = _context.sent;
            _context.next = 51;
            break;

          case 46:
            _context.prev = 46;
            _context.t2 = _context["catch"](40);
            console.log("\u26A0 Error occurred while reading file: ".concat(filepath));
            console.log("Exiting...");
            process.exit(1);

          case 51:
            oldContent = content; // remove headers of the content of the file

            headers = getHeaders(content);
            content = content.replace(headers, ""); // get all regex matches

            regex_matches = content.match(regex); // iterate only pages with regex matches

            if (!(regex_matches !== null)) {
              _context.next = 79;
              break;
            }

            nmbMatches += regex_matches.length;
            _iterator2 = _createForOfIteratorHelper(regex_matches);

            try {
              _loop = function _loop() {
                match = _step2.value;
                var tokens = getCleanTokens(match, options.patternSeparator); // for ease of use

                var text = tokens[0];
                var ref = tokens[1];
                var termReference = termsData.find(function (item) {
                  return item.id === ref;
                });

                if (!termReference) {
                  console.log("\nParsing file \"".concat(filepath, "\"..."));
                  console.log("\u26A0  Could not find the correct term from id " + "\"".concat(ref, "\" in regex match \"").concat(match, "\". Maybe typo or missing term file?"));
                  console.log("Exiting...");
                  process.exit(1);
                }

                var current_file_path = path.resolve(process.cwd(), filepath);
                var relativePath = getRelativePath(current_file_path, termReference.filepath, options);
                var component = "<Term popup=\"".concat(termReference.hoverText, "\" ") + "reference=\"".concat(relativePath, "\">").concat(text, "</Term>");
                content = content.replace(match, component);
              };

              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                _loop();
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }

            ; // since we are inside the if function
            // we can safely assume that we have
            // replaced at least 1 term, so we can
            // now add the import statement after
            // the headers of the file

            content = headers + addJSImportStatement(content); // now the new content can be replaced
            // in the opened file
            // check: dry-run

            if (!options.dryRun) {
              _context.next = 66;
              break;
            }

            diff = gitDiff(oldContent, content, {
              color: true
            });
            console.log("\n! These changes will not be applied in the file " + "".concat(filepath, "\nShowing the output below:\n\n").concat(diff, "\n\n"));
            _context.next = 79;
            break;

          case 66:
            _context.prev = 66;
            _context.next = 69;
            return fs.promises.writeFile(filepath, content, "utf-8");

          case 69:
            result = _context.sent;
            _context.next = 76;
            break;

          case 72:
            _context.prev = 72;
            _context.t3 = _context["catch"](66);
            console.log("\u26A0  An error occurred while writing new data " + "to file: ".concat(filepath, "\n").concat(_context.t3, " \nExiting..."));
            process.exit(1);

          case 76:
            _context.prev = 76;
            console.log("\xBB File ".concat(filepath, " is updated."));
            return _context.finish(76);

          case 79:
            _context.next = 37;
            break;

          case 81:
            _context.next = 86;
            break;

          case 83:
            _context.prev = 83;
            _context.t4 = _context["catch"](35);

            _iterator.e(_context.t4);

          case 86:
            _context.prev = 86;

            _iterator.f();

            return _context.finish(86);

          case 89:
            console.log("\u2713 ".concat(nmbMatches, " term replacements completed."));

          case 90:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[2, 8], [19, 25], [35, 83, 86, 89], [40, 46], [66, 72, 76, 79]]);
  }));
  return _parser.apply(this, arguments);
}

module.exports = parser;